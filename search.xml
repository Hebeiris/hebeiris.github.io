<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java自定义类加载器的实现]]></title>
    <url>%2F2019%2F02%2F22%2FclassLoader%2F</url>
    <content type="text"><![CDATA[2019-2-22 16:21:46 前言java类的加载是将.class文件加载进入内存中，将类的数据结构放置在方法区内，然后在堆区创建class类的对象（垃圾回收）。栈区用来存放局部变量跟基本数据（方法结束后清空）。类的加载用到了类的加载器，加载器可以是java虚拟机中自带的，也可以是用户自定义的。 java自带虚拟机 根（bootstrap）类加载器没有继承ClassLoader，故调用ClassLoader.getParent()是null。是扩展类加载器的父类。专门加载虚拟机的类。 扩展类加载器加载java.ext.dirs指定的类，也可加载jre\lib\ext目录下的类。如Object类。是系统类加载器的父类。 系统类加载器（应用类加载器）从classpath，或者java.class.path所指定的目录下加载类，是用户自定义类加载器的默认父类加载器，用户自定义加载器指定父类加载器方法new ClassLoader(parent,name). 父类委托加载子类加载器在加载过程中，先让父类加载器尝试加载，如果父类加载器尝试失败，子类加载器才接着尝试加载，如果加载失败会爆出ClassNotFound的错误。一个子类加载器只有一个父类加载器。 步入正题 为什么要用这种父类委托加载的形式呢？因为安全性更高一点，子类加载器是没法加载父类加载器加载的类的，父类加载过的类不需要重复加载，这样防止恶意代码冒充java核心库，来兴风作浪。 父类加载器跟子类加载器的关系？（以下简称父类，子类）父类跟子类更像是包装关系，子类的命名空间中的类均可被父类加载，但是父类的类是没法被子类加载的。 自定义的加载器如何加载类？思路：继承ClassLoader，覆盖核心方法findClass，定义私有方法loadClass将其转化成二进制数据流，从而加载到Class类。代码部分MyClassLoader.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class MyClassLoader extends ClassLoader &#123; private String path=&quot;d:\\&quot;; private final String fileType = &quot;.class&quot;; // 类加载器名字 private String name = null; public MyClassLoader(String name)&#123; super(); this.name = name; &#125; public MyClassLoader(ClassLoader parent,String name)&#123; super(parent); this.name = name; &#125; // 调用getClassLoader()时返回此方法，如果不重载，则显示MyClassLoader的引用地址 public String toString()&#123; return this.name; &#125; // 设置文件加载路径 public void setPath(String path)&#123; this.path = path; &#125; protected Class findClass(String name) throws ClassNotFoundException&#123; byte[] data = loadClassData(name); // 参数off代表什么？ return defineClass(name,data,0,data.length); &#125; // 将.class文件读入内存中，并且以字节数形式返回 private byte[] loadClassData(String name) throws ClassNotFoundException&#123; FileInputStream fis = null; ByteArrayOutputStream baos = null; byte[] data = null; try&#123; // 读取文件内容 name = name.replaceAll(&quot;\\.&quot;,&quot;\\\\&quot;); System.out.println(&quot;加载文件名：&quot;+name); // 将文件读取到数据流中 fis = new FileInputStream(path+name+fileType); baos = new ByteArrayOutputStream(); int ch = 0; while ((ch = fis.read()) != -1)&#123; baos.write(ch); &#125; data = baos.toByteArray(); &#125;catch (Exception e)&#123; throw new ClassNotFoundException(&quot;Class is not found:&quot;+name,e); &#125;finally &#123; // 关闭数据流 try &#123; fis.close(); baos.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; return data; &#125; public static void main(String[] args) throws Exception &#123; MyClassLoader loader1 = new MyClassLoader(&quot;loader1&quot;); // 获取MyClassLoader加载器 System.out.println(&quot;MyClassLoader 加载器：&quot; + MyClassLoader.class.getClassLoader()); // 设置加载类查找文件路径 loader1.setPath(&quot;D:\\workspace\\bac5\\java\\&quot;); loader(loader1); &#125; private static void loader(MyClassLoader loader) throws Exception &#123; // MyClassLoader 由系统加载器加载，跟test是不同的加载器，会出现NOClassDefFoundError // 如果类中有package，则加载类名时，需要写全，不然找不到该类,会出现NOClassDefFoundError Class test = loader.loadClass(&quot;test&quot;); Object test1 = test.newInstance(); // test test2 = (test) test1; // 如果MyClassLoader与test非同一个加载器，访问时，需要用到反射机制 Field v1 = test.getField(&quot;v1&quot;);// java反射机制,取test中的静态变量 System.out.println(&quot;被加载出来的类是：&quot;+v1.getInt(test1)); // 卸载，将引用置空 test = null; test1 = null; // 重新加载 test = loader.loadClass(&quot;test&quot;); test1 = test.newInstance(); System.out.println(&quot;test1 hashcode:&quot;+test1.hashCode()); &#125;&#125; test.java12345678public class test &#123; public static int v1= 1; public test()&#123; System.out.println(&quot;调用到了test&quot;); System.out.println(&quot;test加载器为：&quot;+this.getClass().getClassLoader()); &#125;&#125; 注意：1.package，如果加载的类有package文件，则查找时，class的名字应该为包名.类名，不然会报NOClassDefFoundError。2.如果两类不是同一个加载器加载，强制转换，会报NOClassDefFoundError错误。3.不是同一加载器加载的两类如果想访问对方，则需要使用反射机制。 心得在编写代码的过程中，同一个包下的文件，总是会报NOClassDefFoundError。直至看到含包名文件的存储方式，才发现需要将loadClass的文件名称替换成包名.类名的形式，才能正确加载到类。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql sql优化]]></title>
    <url>%2F2019%2F01%2F09%2Fmysql%2F</url>
    <content type="text"><![CDATA[2019-1-9 18:40:07100w数据使用order by排序，耗时5s，加上前后台的数据请求时间，一个页面展示得10几秒，影响性能，故一直在找寻优化sql的办法，将查询时间压缩在毫秒级内。SELECT * FROM [Table] WHERE [索引值] &gt; =(select [索引值] from [Table] limit [pageNum], 1) limit [pageNum],[pageSize]]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven使用日常]]></title>
    <url>%2F2018%2F12%2F25%2FmavenNormal%2F</url>
    <content type="text"><![CDATA[2018-12-25 15:48:39 maven常用记录 打包时，文件复制到指定位置配置12345678910111213141516171819202122232425262728&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-xmls&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!--指定路径--&gt; &lt;outputDirectory&gt;WebContent/WEB-INF/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;!--原文件地址--&gt; &lt;directory&gt;src/resources&lt;/directory&gt; &lt;includes&gt; &lt;!--原文件被打包内容--&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring-boot起步]]></title>
    <url>%2F2018%2F12%2F24%2FspringbootStart%2F</url>
    <content type="text"><![CDATA[2018-12-24 10:55:17spring-boot 使用自动生成类工具，mybatis-generator步骤1：pom.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;!--自动生成映射依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 解析依赖库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;mysql generator&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt; generate &lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--其他配置，如重复生成--&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件，默认为false--&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--允许覆盖生成的文件，默认为false--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!--配置文件指定--&gt; &lt;configurationFile&gt; src/main/resources/mybatis-generator.xml &lt;/configurationFile&gt; &lt;/configuration&gt;&lt;/plugin&gt; 步骤2：mybatis-generator.xml配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;db&quot; targetRuntime=&quot;mybatis3&quot;&gt; &lt;!--链接数据库--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/base&quot; userId=&quot;root&quot; password=&quot;123&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--生成java model存放的地址--&gt; &lt;javaModelGenerator targetPackage=&quot;boot.ms.model&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放的位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成DAO类存放的位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;boot.ms.dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应的表及类名--&gt; &lt;!--&lt;table tableName=&quot;user&quot; domainObjectName=&quot;UserDao&quot; enableCountByExample=&quot;false&quot;&gt;&lt;/table&gt;--&gt; &lt;!--指定生成语句 生成对应的表及类名--&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;UserDao&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 步骤3：配置Run/Debug Configurations配置command line：mybatis-generator:generatespring-boot 使用自动生成类工具，mybatis-generator]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[easyui扩展]]></title>
    <url>%2F2018%2F12%2F03%2Feasyui%2F</url>
    <content type="text"><![CDATA[2018-12-3 16:58:00easyui是常用的前端ui框架，他提供的功能跟方法相当全面，不过在特定环境下还是需要扩展的，这篇就专门记录了扩展内容。 tab中使用自定义idtab中提供的索引值是默认的，它是可以自定义id值的，但是没有提供获取自定义索引值的方法，故需要扩展它getTabId，getSelected，existsById方法。1234567891011121314151617181920212223242526272829303132333435363738394041$.extend($.fn.tabs.methods, &#123; getTabById: function(jq, id) &#123; var tabs = $.data(jq[0], &apos;tabs&apos;).tabs; for(var i = 0; i &lt; tabs.length; i++) &#123; var tab = tabs[i]; if(tab.panel(&apos;options&apos;).id == id) &#123; return tab; &#125; &#125; return null; &#125;, selectById: function(jq, id) &#123; var tab; var tabs = $.data(jq[0], &apos;tabs&apos;).tabs; for (var i = 0; i &lt; tabs.length; i++) &#123; tab = tabs[i]; if (tab.panel(&apos;options&apos;).id == id) &#123; break; &#125; &#125; if (tab != undefined) &#123; var curTabIndex = jq.tabs(&quot;getTabIndex&quot;, tab); jq.tabs(&apos;select&apos;, curTabIndex); &#125; &#125;, existsById: function (jq, id) &#123; return jq.tabs(&apos;getTabById&apos;, id) != null; &#125;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java知识点整理]]></title>
    <url>%2F2018%2F09%2F26%2FjavaProgress%2F</url>
    <content type="text"><![CDATA[2018-9-26 10:31:30编写业务的时候，用规范编写，久而久之，对于技术点就有点模糊，特此记录，方便以后查阅。 对象生命周期1、创建对象==构造实例常见的显示创建对象方式：new(),反射(newInstance()),克隆clone(),反序列化readObject()隐式创建对象：赋直接数，“+”号连接符，虚拟机加载会隐式描述这个类的class实例克隆需要实现Cloneable接口，不然会抛出ClassNotSupportedException异常，克隆出的对象与原对象内存地址不同，但属性值相同，创建对象步骤给对象分配内存，对象的实例变量自动初始化为其变量类型的默认值，初始化对象（赋正确的初始值）常见初始化步骤：变量在声明时被显示初始化，则先把初始值赋给实例变量，再执行构造方法2、构造方法this语法规则只能在一个构造方法中用this调用其他构造方法,实例方法中需要new一个对象，才可调用构造方法如果使用，必须作为构造方法的第一条语句。默认构造方法若类中显示定义一个或多个构造方法，则失去了默认构造方法。在子类继承父类时，父类有默认构造方法不需要写super来继承父类构造方法，java虚拟机会根据继承树从父类开始执行构造方法。设置构造方法为private的意义禁止该类被继承、该类不允许被实例化，与final（可实例化）跟abstract（可继承）的区别,静态工厂方法的形成。3、静态工厂方法静态工厂方法：创建自身实例细节，控制自身实例数目的类静态方法可以返回当前类的子类实例，在创建松耦合的系统接口时会用到.静态工厂可以创建单例类(可自定义为每个线程分配一个实例)，枚举类，实例缓存类(存放在缓存中的实例)，实例缓存不可变类(存放属性值不会更改的类)枚举类好处：提高代码的健壮性，减少出错机会。若支持序列化，则需要实现readResolve()方法，返回对应实例。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5的初接触]]></title>
    <url>%2F2018%2F09%2F21%2Fh5%2F</url>
    <content type="text"><![CDATA[2018-9-21 16:30:58 对于知识的吸取，会让我烦躁的心，安静下来，即使以后用不到，但是比自己不知道的强。 新增标签mark 标注我是标注progress 进度条 进度条time 时间标签当前时间2018-9-21，更新时间:2018-9-20ruby 注释 韓注释：韩浏览器不支持时显示：韩 wbr 换行 到一定宽度的时候，会自动换行我是下一行canvas 图形绘制 我是绘制区域，配合js使用details 基于元素下拉效果 我是下拉菜单菜单1菜单2datalist 搜索框神器 keygen 加密模式选择加密方式：output 进度条选择 0100+=menu 菜单（语义化菜单，没有实际功能）时间 颜色选择 新增属性1、定义script的加载策略，可支持异步加载anyc,defer2、a标签中增加media属性，代表对设备进行优化，hreflang，指定超链接的语言，ref，判断是否是外部链接3、ol中添加倒序排列属性以及其实值设置，reversed（倒序）,start(50)4、menu 新增type, label 属性5、style中新增scoped属性，支持style在body的固定div中进行样式定义6、iframe中新增属性：seamless（去除边框与边距）,srcdoc(直接加载srcdoc中定义的内容),sendbox(禁用跳转页面的表单提交，js，跳转其他源的页面)7、全局属性 data-type:规范属性值hidden:隐藏spellcheck:英文纠错tabindex:光标按照索引值进行跳转contenteditable:是否允许编辑网页内容designMode(on,off):h5为js提供属性,全局是否都可编辑 h5存储1、存储方式：cache(缓存),数据库,磁盘文件，浏览器在h5之前，用cookie存储(安全有问题/会造成主domain污染/请求头会很冗长，一般用于购物车的存储/只能存放4k大小的数据)2、h5存储方式:本地存储、离线缓存、indexDB、web SQLindexDB、web1、存储形式：key：value,key为索引值，value为对象（object）2、查找按照索引值查找，所以在设置字段时，需要createIndex(“name”,”name”,{ unique: false });不然就只能根据key值查找3、transaction 事物提供了增(add)删(delete)改(put/先查get(id)再修改)查(openCursor)的机制离线缓存（ios 3.2 android 2.1）manifest 文件 常用定义了，manifest版本（version），需要缓存的文件（CACHE:），重新拉取的文件（NETWORK:），离线下代替的文件（FALLBACK:）开启缓存:需要先安装apache服务（从官网下载后，需要配置一下路径跟端口号，确保路径是本地路径，端口号没有被占用），在服务器上添加 在apache\conf 文件目录中 mime.type中添加text/cache-manifest appchacemanifest 如果修改文件，需要更新version的版本。更新文件是全局性的，如果页面带参数会生成一张新的缓存页面应用场景：1、单页面请求 2、对实时性要求不高 3、webapp非主流存储：userData(ie5.0-9.0) google gears(64sqlite chrome12.0后放弃，必须用户授权)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小知识]]></title>
    <url>%2F2018%2F09%2F20%2FjsRule%2F</url>
    <content type="text"><![CDATA[2018-9-20 10:03:18总结一些前端常用的技巧1、json格式化输出，JSON.stringify(val, null, “\t”);val值可为对象，可为数组2、固定表格td，不被拉伸 table属性 border-collapse:separate(separate边框独立|collapse相邻边被合并);border-spacing:0px 5px(横向和纵向上的间距);只有border-collapse:separate时生效3、原生js中，用childNodes获取所有子节点，在一些浏览器中，在标签之间会有空字符串的标签，解决方案：nodeType=1是正确的子节点4、计算str中有多少的换行，split(/\r?\n|\r/).length常用封装思想封装对象，将对象的属性，对象相关操作，封装成一个函数，由于js的机制，一个函数是一个对象，可以使用new 实例化，但是会耗费资源，需要慎用。function Ob(){};Ob.prototype={};// 属性，相关函数封装 常用正则1 数字：^[0-9]$2 n位的数字：^\d{n}$3 至少n位的数字：^\d{n,}$4 m-n位的数字：^\d{m,n}$5 零和非零开头的数字：^(0|[1-9][0-9])$6 非零开头的最多带两位小数的数字：^([1-9][0-9])+(.[0-9]{1,2})?$7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$11 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$13 非负整数：^\d+$ 或 ^[1-9]\d|0$14 非正整数：^-[1-9]\d|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$17 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$18 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$19 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$校验字符的表达式1 汉字：^[\u4e00-\u9fa5]{0,}$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$3 长度为3-20的所有字符：^.{3,20}$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$11 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+12 禁止输入含有~的字符：[^~\x22]+特殊需求表达式1 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)$2 域名：/([a-zA-Z0-9]{0,62}.\w{0,62})+.com$|.cn$|.top$|.org$|.gov$|.net$|.edu$|.biz$|.mil$|.name$|.info$|.mobi$|.xyz$|.red$/3 InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}7 身份证号：15或18位身份证：^\d{15}|\d{18}$15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.[A-Z]).{8,10}$12 日期格式：^\d{4}-\d{1,2}-\d{1,2}13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9])$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9])$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})(.[0-9]{1,2})?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$24 备注：这就是最终结果了,别忘了”+”可以用”“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?&lt;/\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue初学]]></title>
    <url>%2F2018%2F09%2F20%2FvueStart%2F</url>
    <content type="text"><![CDATA[2018-9-20 10:02:57最近写一些小的demo，处理一些复杂的数据，其中包含了各种的json对象，array互相嵌套，这才体现出了用vue进行数据绑定的好处。没有具体研究过vue，只是记录一下项目里面遇到的一些常用的 初始化12345678910111213141516171819202122232425var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; sites: [ &#123; name: &apos;Runoob&apos; &#125;, &#123; name: &apos;Google&apos; &#125;, &#123; name: &apos;Taobao&apos; &#125; ], objs: &#123; name: &apos;Runoob&apos; &#125; &#125;, filters:&#123; format:function(obj)&#123; &#125; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 app 实例 return this.sites; &#125; &#125;&#125;) 指令 v-for 使用 循环数组1.不包含index：v-for=”site in sites”,直接调用 site.name;2.包含index：v-for=”(site,index) in sites”,index 为索引;3.循环obj：v-for=”(value,key) in objs”或者v-for=”(value,key,index) in objs”或者v-for=”obj in objs”4.循环整数：v-for=”n in 10” v-bind绑定特定属性，如title，指鼠标悬浮时，显示的提示 v-model数据进行双向绑定，可实现表单值修改时，data中的值对应修改。 自定义过滤器 filters数据格式化处理：自定义format函数，调用 :value=”site|formatJSON” computed属性值计算，可获得data中的所有数据，然后进行计算，调用： 或者 函数方法():调用方法是每次app值重新触发渲染时，都会重新计算 函数方法();reversedMessage:计算机属性调用，只有相关信息发生修改时，才会重新计算。 methods函数绑定，绑定时，如果需要site中的数据，不写引号即可将数据传入方法中 使用情景 获取值由于不兼容jquery所以在vue中无法使用$符号，在标签中添加ref属性，在vue中可以使用this.$refs.[自定义的属性值].value vue-cli 脚手架 安装与启动1234npm install --global vue-cli&gt;vue init webpack 项目名称（新建项目）&gt;cd 项目名称&gt;npm run dev(启动)]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css3标签与使用]]></title>
    <url>%2F2018%2F09%2F14%2Fcss3%2F</url>
    <content type="text"><![CDATA[2018-9-14 10:22:13 帮助某人学习前端，可惜我之前没接触过css3，只能从头开始记录了。 常用标签border-image 边框图片用法：background:url(xx.jpg) 5 10 15 20 no-repeat;说明：5 10 15 20 分别是4个边框裁剪原图的宽度 no-repeat: 图片延伸有3个可选项，repeat，round（平铺）,stretch(拉伸) box-shadow 边框阴影用法：box-shadow:4px 2px 6px #333333; 说明：box-shadow: X轴偏移量(可负) Y轴偏移量(可负) 阴影模糊半径 阴影扩展半径 [阴影颜色] 投影方式;rgba(R,G,B,A)说明：以上R、G、B三个参数，正整数值的取值范围为：0 - 255。A的取值范围为：0.0% - 100.0%。linear-gradient线性渐变用法：background:linear-gradient(to bottom,red,yellow,blue)说明：to top 从下到上，to bottom 从上到下，to left 从右到左，to right 从左到右， 扩展：to top left 从右下角到左上角，to top right 从左下角到右上角,to bottom left,to bottom right 一行显示不下后，添加省略号/b&gt;用法：需要出现省略号的用法：text-overflow:ellipsis; overflow:hidden; white-space:nowrap; 说明：text-overflow:clip|ellipsis,clip 剪切，ellipsis显示省略号 white-space:nowrap|break-word,nowrap 强制文本一行显示，break-word在区间内换行（一般用浏览器的默认，即normal）使用特殊字体：嵌入字体@font-face说明：@font-face { font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;}文本阴影text-shadow用法：text-shadow: 0 1px 1px #fff说明：text-shadow: X轴偏移量(可负) Y轴偏移量(可负) 模糊程度[0为不模糊，值越大越模糊] 颜色;background-origin 背景起始位置说明：background-origin ： border-box(从边框开始) | padding-box(从内边距开始) | content-box(从内容开始);background-clip 背景剪裁说明：background-clip ： border-box(从边框开始裁剪) | padding-box(从边框开始裁剪) | content-box(从边框开始裁剪) | no-clip(不剪裁);background-size 调整背景大小说明：background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover(填满整个容器) | contain(宽跟高拉伸到容器的一边为止);多图背景拼接用法： background:url(http://static.mukewang.com/static/img/logo_index.png) no-repeat 0px 0px/200px 80px,url(http://static.mukewang.com/static/img/logo_index.png) no-repeat right bottom/150px 50px;说明: background ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],…可以把上面的缩写拆解成以下形式：background-image:url1,url2,…,urlN;如果有 size 值，需要紧跟 position 并且用 “/“ 隔开； css3新增属性3个属性选择器E[attr^=”val”]:attr属性值开头为valE[attr$=”val”]:attr属性值结尾为valE[attr*=”val”]:attr属性值包含val伪类选择器:root说明：:root{background:orange} 等价于html {background:orange;}:not 否定选择器用法：input:not([type=”submit”]){ border:1px solid red;}说明：除type=submit外的所有input 标签，设置边框，:not 给除当前元素外的所有元素设置样式:empty 空标签选择器说明：所选择没有有任何内容包括一个空格的标签:target 目标选择器 用在href上 用法：#id:target{ 设定样式 }说明：href 值为#id时，点击href所在标签，#id节点变成 设定样式。即作用在目标对象上的样式:first-child,:last-child说明：第一个子元素,最后一个子元素nth-child(n) 正数说明：用来定位某个父元素的一个或多个特定的子元素;:nth-child(2n)选择所有偶数行，:nth-child(2n+1)选择所有基数行当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素n可以是表达式，数字，关键词：odd(奇数行)，even(偶数行):nth-last-child(n) 倒数说明：倒数第n个子元素:first-of-type ,:last-of-type说明：第一个(最后一个)指定类型的子元素:nth-of-type(n) 正数说明：第n个指定类型的子元素:nth-last-of-type(n)说明：倒数第n个指定类型的子元素:only-child用法：li:only-child说明：当子元素li没有兄弟节点时，使用:only-child 可选中，如果有兄弟节点，则不被选中父级元素下唯一一个元素:only-of-type说明：父级元素下的唯一一个指定类型的元素:enabled,:disabled,:checked说明：作用于是否可用，被选中的元素::selection说明：当鼠标选中网页文本时，文字颜色，背景更改，火狐上需要使用::-moz-selection:read-only(:-moz-read-only),:read-write(:-moz-read-write)说明：获取(非)只读状态下的元素 css3动画效果rotate()用法：transform:rotate(20deg);说明：rotate([正值|负值]deg)，ios跟火狐需要另外一个属性 -webkit-transform,-moz-transform 带替 transform;scale()用法：transform:scale(2);说明：scale([正值])，值在0,1之间为缩小，大于1为放大;translate()用法：transform:translate(2px,2px);说明：translate(X,Y),位移，可用于垂直居中;skew()用法：transform:skew(2px,2px);说明：translate(Xdeg,Ydeg),扭曲;matix()用法：transform:matix(1,1,1,1,1,1);说明：matix，矩阵，简单的就是将位移，扭曲，放大等动态效果融合成一行代码transform-origin()用法：transform:transform-origin(0,0);说明：transform-origin()，修改原点，可以的值为center/top center/bottom center/left center/right center注意点：transform 不同浏览器的书写规范 /Mozilla内核浏览器：firefox3.5+/ -moz-transform: rotate | scale | skew | translate ; /Webkit内核浏览器：Safari and Chrome/ -webkit-transform: rotate | scale | skew | translate ; /Opera/ -o-transform: rotate | scale | skew | translate ; /IE9+/ -ms-transform: rotate | scale | skew | translate ; /标准/ transform: rotate | scale | skew | translate ;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex嵌入安卓]]></title>
    <url>%2F2018%2F08%2F29%2Fweex%2F</url>
    <content type="text"><![CDATA[2018-8-29 13:11:15第一次接触weex框架，简直一脸懵逼。官方文档，只想说，呵呵，误打误撞，终于搞定了weex嵌入安卓端页面了。这篇就记录一下关键点。 安装跟着官方demo走,当走到 npm start 后会跳出页面，意味着一个weex项目已经启动好了。下图为weex项目目录，其中的一些相关说明备注 安卓代码编写使用sdk方式嵌入已有的安卓代码，官方demo我根据官方给出的接入代码，将其整合为一个项目demo，可以点击此处下载查看,仅支持android studio 3.0+的版本步骤说明1、引包官方给出的 recyclerview，support，appcompat 是安卓的最低支持版本，创建项目的时候会自动创建，不需要重新引入compile ‘com.alibaba:fastjson:1.1.46.android’compile ‘com.taobao.android:weex_sdk:0.5.1@aar’2、实现图片下载类实现 IWXImgLoaderAdapter 接口，可以直接使用官方的demo3、初始化weex sdk继承Application 后，可以直接使用官方的demo，不过需要在安卓文件的 AndroidManifest.xml 中配置。android:name=”.WXApplication”4、页面嵌入在weex/dist/目录下，拷贝一份.js文件至main/assets目录下，没有可以自己创建。java代码，实现 IWXRenderListener 接口，可以直接使用官方的demo，将WXFileUtils.loadFileContent中的hello.js 更换为刚刚拷贝至项目的.js文件名。5.安卓AndroidManifest.xml配置下面代码是根据官方demo的配置来配置的请求远程.js文件 方法 weex 与安卓交互Module 扩展weex调用安卓方法即 js 调原生方法，根据官方demo，需要自定义model.官方demo中，WXSDKEngine.registerModule(“MyModule”, MyModule.class);是写在 WXApplication 文件中的，在WXApplication中注册后，前端才可调用到MyModule中的方法native 方法1：1234@JSMethod (uiThread = false)public String fireEventSyncCall1(String msg)&#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();&#125; weex调用 model.fireEventSyncCall1(“”);native 方法实现2，返回特定值（weex新包支持）：1234@JSMethod (uiThread = false)public String fireEventSyncCall()&#123; return &quot;1234&quot;;&#125; weex调用 var a = model.fireEventSyncCall1();native 方法实现3，回调去js：12345@JSMethod(uiThread = false)public void printLog(String msg,JSCallback callback) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); callback.invoke(&quot;success&quot;);&#125; weex调用 model.printLog(‘’,function(参数回调){});安卓向weex输出数据 weex界面编写weex界面无法使用jquery的方法，很多界面渲染需要靠数据绑定来实现。1、不支持float，需要使用display:flex布局]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[有了男票以后要做的100件事情]]></title>
    <url>%2F2018%2F08%2F24%2Ffriends%2F</url>
    <content type="text"><![CDATA[2018-8-24 17:38:57 在没有男票的这段日子里，好好的等待着，开始胡思乱想，有男票以后要做的100件事情。 去上海迪士尼 去水上乐园 –一直在海韵之星玩，不敢去其他的地方，等有了男票以后，希望能陪我去水上乐园。 去酒吧街 –有了男票的保驾护航，就能出去见见世面啦，O(∩_∩)O哈哈~ 半夜在外面踏马路 –学生时期想做，却不敢做的事情。 一起学习 –学生时期想做，却一直没法实现的事情。 说，我爱你 –内敛，腼腆，不善于表达自我。希望遇到了未来的你，能理解我，我也尝试着去改变，每天跟你说，我爱你，加深彼此之间的信任。 拍照 –真的很想把你记录下来啊。]]></content>
      <categories>
        <category>心情</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[书单整理]]></title>
    <url>%2F2018%2F08%2F24%2F%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[2018-8-24 14:17:39有生之年，希望能把书单摞起来。博闻强识，修生养性。 绿色为已读 工具书JAVA面向对象编程(孙卫琴)看透spring mvc：源代码分析与实践深入理解java虚拟机：JVM高级特性与最近实践 纪实类面纱下的阿富汗万水千山走过人类简史时间简史我们仨美食，祈祷，恋爱上下五千年 小说类东野奎吾系列恶意白夜行圣女的救济解忧杂货店秘密浪花少年侦探团造彩虹的人变身名侦探的守则祈祷落幕时麒麟之翼 传记类人间失格追风筝的人灿烂千阳狐狸男孩杜月笙：上海教父京华烟云简爱呼啸山庄 龙应台：人生三书亲爱的安德烈孩子你慢慢来目送 悬疑类死神的精确度花与爱丽丝杀人事件 科幻类三体 童话小王子麦田里的守望者一千零一夜 励志类你自以为的极限，只是别人的起点高效15法则女人的格局决定结局人性的弱点 散文愿生命从容]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo随笔]]></title>
    <url>%2F2018%2F08%2F22%2Fhexo%2F</url>
    <content type="text"><![CDATA[2018-8-22 11:50:44 使用了hexo，踩过了的坑，以及一些心得 修改上传命令行 编译语句 1hexo g 提交至git上语句 1hexo d 每次修改好后可在cmd中直接hexo g，hexo d 同步git代码。 .md文件中图片添加1.将图片存放在public/css/images 直接使用img标签引入2.将找出编译好的html文件，直接引入1&lt;img src=&quot;/../css/images/5.png&quot; /&gt; 3.Markdown语法123![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 界面美化 首页布局修改 官方布局landscape 文件目录说明 landscape-&gt;_config.yml文件说明 landscape-&gt;layout 文件目录说明 landscape-&gt;layout-&gt;_widget 文件目录说明 自定义.ejs 页面控件 编写 编写格式与css编写一致，一些特定的数据，如文章数，可查看官网api 显示值与方法调用与jsp类似 &lt;%= 需要显示的值 %&gt; &lt;% 内置方法 %&gt; 显示编写的页面此处我显示在侧边栏上面，打开sidebar.ejs文件，发现侧边栏配置是循环theme.widgets后，可以打开_config.yml 查看widgets变量配置，再其中添加自定义的.ejs的文件名，hexo编译后会自动生成html页面。 首页文件只显示部分只需要在文章截止下方添加注释过的”more”即可]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java常用方法小结]]></title>
    <url>%2F2018%2F08%2F18%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[比较方法12345Collections.sort(list, new Comparator&lt; Object &gt;() &#123; @Override public int compare(Object arg0, Object arg1) &#123; return arg0 - arg1(比较条件相减,不为付,两个对象位置调换);&#125;); 遍历map方法 方法一1234567Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); &#125; 方法二遍历map中的键 12345for (Integer key : map.keySet()) &#123; System.out.println(&quot;Key = &quot; + key); &#125; 遍历map中的值 1234for (Integer value : map.values()) &#123; System.out.println(&quot;Value = &quot; + value); &#125; 将object中的数据提取出来,object{[],[]}12JSONArray result = JSON.parseArray(object.toString()); JSONObject item = (JSONObject) result.get(0); 随机cid Identities.aSyncMakeUUID() 日期相关 日期互换 Calendar和Date的转化(1) Calendar转化为Date12Calendar cal=Calendar.getInstance();Date date=cal.getTime(); (2) Date转化为Calendar123Date date=new Date();Calendar cal=Calendar.getInstance();cal.setTime(date); date赋值1234567SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM&quot;);Date date = formatter.parse(&quot;2016-7&quot;);Calendar cal = Calendar.getInstance();cal.setTime(date);System.out.println(formatter.format(cal.getTime()));System.out.println(cal.get(Calendar.MONTH) + 1);// 获取月System.out.println(cal.get(Calendar.YEAR));// 获取年 date转stringformatter.format(date); 已知年月,与第几周,求一周的开始日期与结束日期 第二周开始的第一天123456 int day = cal.get(Calendar.DAY_OF_WEEK)-1; cal.add(Calendar.DAY_OF_WEEK, 7-day);// 每周天数截至日期Date checkTimeMax = cal.getTime();cal.add(Calendar.DAY_OF_WEEK, -6);// 每周天数开始日期Date checkTimeMin = cal.getTime(); 日期加天数123456public static Date getAddDayDate(Date date, int day) &#123; Calendar calendar = new GregorianCalendar(); calendar.setTime(date); calendar.add(Calendar.DAY_OF_WEEK, day); return calendar.getTime();&#125; 配置文件读取12345678import java.util.Properties;import org.springframework.core.io.support.PropertiesLoaderUtils; // 地址public static final String BAC_PROPERTY_FILE = &quot;bac.properties&quot;; // 取值Properties ps = PropertiesLoaderUtils.loadAllProperties(BAC_PROPERTY_FILE);SmsAccount = AESEncrypter.decrypt(ps.getProperty(&quot;sms.account&quot;,null));SmsPassword = AESEncrypter.decrypt(ps.getProperty(&quot;sms.password&quot;,null)); 截取两位小数123Double f = 111231.5585; String pay_money = f.toString();Double pString = Double.parseDouble(pay_money.substring(0, pay_money.indexOf(&quot;.&quot;)+3)); .xml 文字标签 &lt;![CDATA[ ]]&gt; .vm文件填充123456789101112131415161718192021222324252627282930private void template(Map&lt;String, String&gt; params, HttpServletResponse resp, String templateFile) throws IOException &#123; Properties p = new Properties(); p.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, URL); Velocity.init(p); // 取得VelocityContext作用域 VelocityContext context = new VelocityContext(); // 将list放入context作用域 if (params != null) &#123; context.put(&quot;total_fee&quot;, params.get(&quot;total_fee&quot;)); context.put(&quot;status&quot;, &quot;1&quot;); &#125; Template template = null; try &#123; // 载入模板文件 template = Velocity.getTemplate(templateFile); &#125; catch (ResourceNotFoundException rnfe) &#123; System.out.println(&quot;Example : error : cannot find template &quot; + templateFile); &#125; catch (ParseErrorException pee) &#123; System.out.println(&quot;Example : Syntax error in template &quot; + templateFile + &quot;:&quot; + pee); &#125; BufferedWriter writer = new BufferedWriter(resp.getWriter()); if (template != null) template.merge(context, writer); writer.flush(); writer.close(); &#125; 常用正则 手机号码正则判断1234private static final String PHONE_PATTERN = &quot;^1(3[0-9]|4[5,7]|5[0-3,5-9]|8[0-9])\\d&#123;8&#125;$&quot;; private static final String yd = &quot;^((13[4-9])|(147)|(15[0-2,7-9])|(18[2-4,7-8]))\\d&#123;8&#125;$&quot;; private static final String lt = &quot;^((13[0-2])|(145)|(15[5-6])|(18[5-6]))\\d&#123;8&#125;$&quot;; private static final String dx = &quot;^((133)|(153)|(18[0,9]))\\d&#123;8&#125;$&quot;; 图片后缀正则判断.+(.JPEG|.jpeg|.JPG|.jpg|.GIF|.gif|.BMP|.bmp|.PNG|.png)$ 获取标签内容12345Matcher matcher = Pattern.compile(&quot;&lt;code.*?&gt;([\\s\\S]*?)&lt;/code&gt;&quot;).matcher(str);String content = &quot;&quot;;while (matcher.find()) &#123; content += matcher.group(1)+&quot;++++++++++++++++++&quot;;&#125; 取Object 中list的值12345678910111213Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();List&lt;Integer&gt; status = new ArrayList&lt;Integer&gt;();status.add(1);status.add(0);map.put(&quot;status&quot;, status);Object obj = map.get(&quot;status&quot;);if (obj instanceof List) &#123; List&lt;Integer&gt; list = (List&lt;Integer&gt;) obj; for (Integer item : list) &#123; System.out.println(&quot;++++item:&quot; + item); &#125;&#125; 框架相关枚举1.定义12345678910111213141516171819public enum VoucherType &#123; // 利用构造函数传参 OIL(0), FARE(1);// 可以定义多个变量，如oil（0，&quot;油&quot;） // 定义私有变量 private int code; // 构造函数，枚举类型只能为私有 private VoucherType(int code) &#123; this.code = code; &#125; // 改写toString()方法 @Override public String toString() &#123; return String.valueOf(this.code); &#125; // 根据code获取值 &#125; 数据请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private static String invoke(DefaultHttpClient httpclient, HttpUriRequest httpost) &#123; HttpResponse response = sendRequest(httpclient, httpost); String body = paseResponse(response); return body;&#125;private static HttpResponse sendRequest(DefaultHttpClient httpclient, HttpUriRequest httpost) &#123; HttpResponse response = null; try &#123; response = httpclient.execute(httpost); &#125; catch (ClientProtocolException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return response;&#125;private static String paseResponse(HttpResponse response) &#123; log.info(&quot;get response from http server..&quot;); HttpEntity entity = response.getEntity(); log.info(&quot;response status: &quot; + response.getStatusLine()); String charset = &quot;utf-8&quot;; log.info(charset); String body = null; try &#123; body = EntityUtils.toString(entity, &quot;utf-8&quot;); log.info(body); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return body;&#125;private static HttpPost postForm(String url, Map&lt;String, String&gt; params) &#123; HttpPost httpost = new HttpPost(url); List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); Set&lt;String&gt; keySet = params.keySet(); for (String key : keySet) &#123; nvps.add(new BasicNameValuePair(key, params.get(key))); &#125; try &#123; log.info(&quot;set utf-8 form entity to httppost&quot;); httpost.setEntity(new UrlEncodedFormEntity(nvps, &quot;UTF-8&quot;)); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return httpost;&#125; bean转map1234567891011121314151617181920// java bean类CarModelBean bean = new CarModelBean(); bean.setPrice(new BigDecimal(&quot;111.11&quot;)); // 找到bean类的属性集合 Field[] fields = bean.getClass().getDeclaredFields(); for (Field item : fields) &#123; // 找到bean类的属性名 String name = item.getName(); if (&quot;price&quot;.equals(name)) &#123; // 由属性名找到属性值 name = name.substring(0,1).toUpperCase()+name.substring(1); //将属性的首字符大写，方便构造get，set方法 Method m = bean.getClass().getMethod(&quot;get&quot;+name); // 将属性值变为对应的数据类型 Class&lt;?&gt; o = item.getType(); Object value = m.invoke(bean); value = o.cast(value); log.info(value+&quot;&quot;); &#125; &#125; 图片上传123456789101112131415161718192021222324252627282930String path = request.getServletContext().getRealPath(&quot;/images&quot;); log.info(&quot;文件根目录路径:&quot; + path); String filename = System.currentTimeMillis() + &quot;.&quot; + image_mode; String realPath = path +&quot;/&quot;+ filename; log.info(&quot;文件路径:&quot; + realPath); FileOutputStream outSteam = new FileOutputStream(new File(realPath));&lt;em&gt; 验证随机字母数字组合是否纯数字与纯字母&lt;/em&gt;/** * 验证随机字母数字组合是否纯数字与纯字母 * * @param str * @return true 是 ， false 否 */ public static boolean isRandomUsable(String str) &#123; // String regExp = // &quot;^[A-Za-z]+(([0-9]+[A-Za-z0-9]+)|([A-Za-z0-9]+[0-9]+))|[0-9]+(([A-Za-z]+[A-Za-z0-9]+)|([A-Za-z0-9]+[A-Za-z]+))$&quot;; String regExp = &quot;^([0-9]+)|([A-Za-z]+)$&quot;; Pattern pat = Pattern.compile(regExp); Matcher mat = pat.matcher(str); return mat.matches(); &#125;&lt;em&gt;BigDecimal用法&lt;/em&gt;BigDecimal.setScale();//用于格式化小数点 setScale(1);//表示保留以为小数，默认用四舍五入方式 setScale(1,BigDecimal.ROUND_DOWN);//直接删除多余的小数位，如2.35会变成2.3 setScale(1,BigDecimal.ROUND_UP);//进位处理，2.35变成2.4 setScale(1,BigDecimal.ROUND_HALF_UP);//四舍五入，2.35变成2.4 setScaler(1,BigDecimal.ROUND_HALF_DOWN);//四舍五入，2.35变成2.3，如果是5则向下舍 文件夹创建，多级 12345String saveFlie = path + &quot;/&quot; + packagename + &quot;/&quot; + date;File savePath = new File(saveFlie);// 创建新文件if (!savePath.exists()) &#123; savePath.mkdirs();&#125; FastJson转mapMap&lt;String, Object&gt; map = JSON.parseObject(jsonStr,new TypeReference&lt;Map&lt;String, Object&gt;&gt;(){} ); 获取文件的路径(1).Test.class.getResource(“”)得到的是当前类FileTest.class文件的URI目录。不包括自己！(2).Test.class.getResource(“/“)得到的是当前的classpath的绝对URI路径。(3).Thread.currentThread().getContextClassLoader().getResource(“”)得到的也是当前ClassPath的绝对URI路径。(4).Test.class.getClassLoader().getResource(“”)得到的也是当前ClassPath的绝对URI路径。(5).ClassLoader.getSystemResource(“”)得到的也是当前ClassPath的绝对URI路径。尽量不要使用相对于System.getProperty(“user.dir”)当前用户目录的相对路径，后面可以看出得出结果五花八门。(6) new File(“”).getAbsolutePath()也可用。 文件上传 if(!file.isEmpty()){ // 文件不为空，则写入磁盘中 String name = file.getOriginalFilename(); // class文件目录 File f = new File(this.getClass().getResource(&quot;/&quot;).getPath()); // 没有文件则新增 File path = new File(f.getParentFile().getParent()+&quot;/&quot;+name) ; FileOutputStream os = new FileOutputStream(path.getPath()); InputStream in = file.getInputStream(); int b = 0; while ((b=in.read())!=-1){ os.write(b); } //清空缓冲区数据,保证数据完全输出 os.flush(); os.close(); in.close(); }]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
</search>
